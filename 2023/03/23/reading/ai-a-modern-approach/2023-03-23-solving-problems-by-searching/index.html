<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CAgbalumo:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"aquietzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"width":null},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="When the correct action to take is not immediately obvious, an agent may need to plan ahead: to consider a sequence of actions that form a path to a goal state. Such an agent is called a problem-solvi">
<meta property="og:type" content="article">
<meta property="og:title" content="Solving Problems by Searching">
<meta property="og:url" content="https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/index.html">
<meta property="og:site_name" content="NullSpace">
<meta property="og:description" content="When the correct action to take is not immediately obvious, an agent may need to plan ahead: to consider a sequence of actions that form a path to a goal state. Such an agent is called a problem-solvi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-22T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-19T07:11:29.526Z">
<meta property="article:author" content="bifnudo">
<meta property="article:tag" content="方法论">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="搜索">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/","path":"2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/","title":"Solving Problems by Searching"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Solving Problems by Searching | NullSpace</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BCZ3TL69CD"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-BCZ3TL69CD","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NullSpace</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#problem-solving-agents"><span class="nav-number">1.</span> <span class="nav-text">Problem-Solving Agents</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#search-problems-and-solutions"><span class="nav-number">1.1.</span> <span class="nav-text">Search Problems and
Solutions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#formulating-problems"><span class="nav-number">1.2.</span> <span class="nav-text">Formulating Problems</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#search-algorithms"><span class="nav-number">2.</span> <span class="nav-text">Search Algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#best-first-search"><span class="nav-number">2.1.</span> <span class="nav-text">Best-first Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#search-data-structures"><span class="nav-number">2.2.</span> <span class="nav-text">Search Data Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#node"><span class="nav-number">2.2.1.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#frontier"><span class="nav-number">2.2.2.</span> <span class="nav-text">Frontier</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#measuring-problem-solving-performance"><span class="nav-number">2.3.</span> <span class="nav-text">Measuring Problem-Solving
Performance</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uninformed-search-strategies"><span class="nav-number">3.</span> <span class="nav-text">Uninformed Search Strategies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#breadth-first-search"><span class="nav-number">3.1.</span> <span class="nav-text">Breadth-First Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dijkstras-algorithm-or-uniform-cost-search"><span class="nav-number">3.2.</span> <span class="nav-text">Dijkstra’s Algorithm
or Uniform-Cost Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#depth-first-search-and-the-problem-of-memory"><span class="nav-number">3.3.</span> <span class="nav-text">Depth-First Search
and the Problem of Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#depth-limited-and-iterative-deepening-search"><span class="nav-number">3.4.</span> <span class="nav-text">Depth-Limited and
Iterative Deepening Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bidirectional-search"><span class="nav-number">3.5.</span> <span class="nav-text">Bidirectional Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#comparing-uninformed-search-algorithms"><span class="nav-number">3.6.</span> <span class="nav-text">Comparing Uninformed
Search Algorithms</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#informedheuristic-search-strategies"><span class="nav-number">4.</span> <span class="nav-text">Informed(Heuristic) Search
Strategies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#greedy-best-first-search"><span class="nav-number">4.1.</span> <span class="nav-text">Greedy Best-First Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#a-search"><span class="nav-number">4.2.</span> <span class="nav-text">A* Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#search-contours"><span class="nav-number">4.3.</span> <span class="nav-text">Search Contours</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#satisficing-search-inadmissible-heuristic-and-weighted-a"><span class="nav-number">4.4.</span> <span class="nav-text">Satisficing
Search: Inadmissible Heuristic and Weighted A*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-bounded-search"><span class="nav-number">4.5.</span> <span class="nav-text">Memory-Bounded Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bidirectional-heuristic-search"><span class="nav-number">4.6.</span> <span class="nav-text">Bidirectional Heuristic
Search</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#heuristic-functions"><span class="nav-number">5.</span> <span class="nav-text">Heuristic Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#the-effect-of-heuristic-accuracy-on-performance"><span class="nav-number">5.1.</span> <span class="nav-text">The Effect of
Heuristic Accuracy on Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generating-heuristic-from-relaxed-problems"><span class="nav-number">5.2.</span> <span class="nav-text">Generating Heuristic
from Relaxed Problems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generating-heuristics-from-subproblems-pattern-databases"><span class="nav-number">5.3.</span> <span class="nav-text">Generating
Heuristics from Subproblems: Pattern Databases</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generating-heuristics-with-landmarks"><span class="nav-number">5.4.</span> <span class="nav-text">Generating Heuristics with
Landmarks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#summary"><span class="nav-number">6.</span> <span class="nav-text">Summary</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bifnudo"
      src="/assets/images/me.webp">
  <p class="site-author-name" itemprop="name">bifnudo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/aquietzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aquietzero" rel="noopener me" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/aquietzero" title="豆瓣 → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;aquietzero" rel="noopener me" target="_blank">豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoyunhaosss@gmail.com" title="E-Mail → mailto:zhaoyunhaosss@gmail.com" rel="noopener me" target="_blank">E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/images/me.webp">
      <meta itemprop="name" content="bifnudo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NullSpace">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Solving Problems by Searching | NullSpace">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Solving Problems by Searching
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-23T00:00:00+08:00">2023-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reading/" itemprop="url" rel="index"><span itemprop="name">Reading</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>When the correct action to take is not immediately obvious, an agent
may need to plan ahead: to consider a sequence of actions that form a
path to a goal state. Such an agent is called a <strong>problem-solving
agent</strong>, and the computational process it undertakes is called
<strong>search</strong>.</p>
<h1 id="problem-solving-agents">Problem-Solving Agents</h1>
<p>If the environment is completely unknown, then the agent can do no
better than to execute one of the actions at random. With access to
information about the world, the agent can follow the four-phase
problem-solving process:</p>
<ul>
<li><strong>Goal formulation</strong>: Goals organize behavior by
limiting the objectives and hence the actions to be considered.</li>
<li><strong>Problem formulation</strong>: The agent devises a
description of the states and actions necessary to reach the goal —— an
abstract model of the relevant part of the world.</li>
<li><strong>Search</strong>: The agent simulates sequences of actions in
its model, searching until it finds a sequence of actions that reaches
the goal. Such a sequence si called a <strong>solution</strong>.</li>
<li><strong>Execution</strong>: The agent can now execute the actions in
the solution, one at a time.</li>
</ul>
<p>In a fully observable, deterministic, known environment, the solution
to any problem is a fixed sequence of actions. This is an
<strong>open-loop</strong> system: ignoring the percepts breaks the loop
between agent and environment. If there is a chance that the model is
incorrect, or the environment is nondeterministic, then the agent would
be safer using a <strong>closed-loop</strong> approach that monitors the
percepts.</p>
<h2 id="search-problems-and-solutions">Search Problems and
Solutions</h2>
<p>A search problem can be defined formally as follows:</p>
<ul>
<li><strong>state space</strong>: A set of possible states that the
environment can be in.</li>
<li><strong>initial state</strong>: that the agent starts in.</li>
<li>A set of one or more <strong>goal states</strong>.</li>
<li>The <strong>actions</strong> available to the agent. Given a state
<span class="math inline">\(s\)</span>, <span
class="math inline">\(\text{ACTIONS}(s)\)</span> returns a finite set of
actions that can be executed in <span class="math inline">\(s\)</span>.
We say that each of these actions is <strong>applicable</strong> in
<span class="math inline">\(s\)</span>.</li>
<li>A <strong>transition model</strong>, which describes what each
action does. <span class="math inline">\(\text{RESULT}(s, a)\)</span>
returns the state that results from doing action <span
class="math inline">\(a\)</span> in state <span
class="math inline">\(s\)</span>.</li>
<li>An <strong>action cost function</strong>, denoted by <span
class="math inline">\(\text{ACTION-COST}(s, a, s&#39;)\)</span>, that
gives the numeric cost of applying action <span
class="math inline">\(a\)</span> in state <span
class="math inline">\(s\)</span> to reach <span
class="math inline">\(s&#39;\)</span>.</li>
</ul>
<p>A sequence of actions forms a <strong>path</strong>, and a
<strong>solution</strong> is a path from the initial state to a goal
state. An <strong>optimal solution</strong> has the lowest path cost
among all solutions.</p>
<h2 id="formulating-problems">Formulating Problems</h2>
<p>Formulating problems is a process of finding an appropriate
<strong>level of abstraction</strong>. The abstraction is
<strong>valid</strong> if we can elaborate any abstract solution into a
solution in the more detailed world. The abstraction is
<strong>useful</strong> if carrying out each of the actions in the
solution is easier than the original problem.</p>
<h1 id="search-algorithms">Search Algorithms</h1>
<p>A <strong>search algorithm</strong> takes a search problem as input
and returns a solution, or an indication of failure. One type of
algorithms superimposes a <strong>search tree</strong> over the state
space graph, forming various paths from the initial state, trying to
find a path that reaches a goal state.</p>
<p>Each node in the search tree corresponds to a state in the state
space and the edges in the search tree correspond to actions. The root
of the three corresponds to the initial state of the problem.</p>
<h2 id="best-first-search">Best-first Search</h2>
<p>A general approach for expand the frontier is called
<strong>best-first search</strong>, in which a node <span
class="math inline">\(n\)</span> is chosen, with minimum value of some
<strong>evaluation function</strong>, <span
class="math inline">\(f(n)\)</span>.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Best-first Search Algorithm</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BestFirstSearch</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">problem</span>: <span class="title class_">Problem</span>, <span class="attr">f</span>: <span class="title class_">EvaluateFunction</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Solution</span> | <span class="title class_">Failure</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(&#123; <span class="attr">state</span>: problem.<span class="property">initial</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> frontier = <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Node</span>&gt;(&#123; <span class="attr">orderBy</span>: f &#125;)</span><br><span class="line">    <span class="keyword">const</span> reached = &#123; [problem.<span class="property">initial</span>]: node &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!frontier.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        node = frontier.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">if</span> (problem.<span class="title function_">isGoal</span>(node.<span class="property">state</span>)) <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> children = <span class="title class_">Expand</span>(problem, node)</span><br><span class="line">        children.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> s = child.<span class="property">state</span></span><br><span class="line">            <span class="keyword">if</span> (!reached[s] || child.<span class="property">pathCost</span> &lt; reached[s].<span class="property">pathCost</span>) &#123;</span><br><span class="line">                reached[s] = child</span><br><span class="line">                frontier.<span class="title function_">push</span>(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Expand</span>(<span class="params"><span class="attr">problem</span>: <span class="title class_">Problem</span>, <span class="attr">node</span>: <span class="title class_">Node</span></span>): <span class="title class_">Node</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> s = node.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> problem.<span class="title function_">actions</span>(s).<span class="title function_">map</span>(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> sp = problem.<span class="title function_">result</span>(s.<span class="property">action</span>)</span><br><span class="line">        <span class="keyword">const</span> cost = node.<span class="property">pathCost</span> + problem.<span class="title function_">actionCost</span>(s, action, sp)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(&#123;</span><br><span class="line">            <span class="attr">state</span>: s,</span><br><span class="line">            <span class="attr">parent</span>: node,</span><br><span class="line">            <span class="attr">action</span>: action,</span><br><span class="line">            <span class="attr">pathCost</span>: cost,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<aside>
<p>💡 By employing different <span class="math inline">\(f(n)\)</span>
functions, we get different specific algorithms.</p>
</aside>
<h2 id="search-data-structures">Search Data Structures</h2>
<h3 id="node">Node</h3>
<p>A node in the tree is represented by a data structure with four
components:</p>
<ul>
<li><strong>node.STATE</strong>: the state to which the node
corresponds</li>
<li><strong>node.PARENT</strong>: the node in the tree that generated
this node</li>
<li><strong>node.ACTION</strong>: the action that was applied to the
parent’s state to generate this node</li>
<li><strong>node.PATH-COST</strong>: the <strong>total cost</strong> of
the path from the initial state to this node.</li>
</ul>
<p>Following the PARENT pointers back from a node allows to recover the
states and actions along the path to that node.</p>
<h3 id="frontier">Frontier</h3>
<p>A data structure is needed to store the frontier. The appropriate
choice is a queue of some kind.</p>
<ul>
<li><strong>IS-EMPTY(frontier)</strong>: returns true only if there are
no nodes in the frontier</li>
<li><strong>POP(frontier)</strong>: removes the top node from the
frontier and returns it</li>
<li><strong>TOP(frontier)</strong>: returns (but does not remove) the
top node of the frontier</li>
<li><strong>ADD(node, frontier)</strong>: inserts node into its proper
place in the queue</li>
</ul>
<p>Three kinds of queues are used in search algorithms</p>
<ul>
<li>A <strong>priority queue</strong> first pops the node with the
minimum cost according to some evaluation function, <span
class="math inline">\(f\)</span>. It is used in <strong>best-first
search</strong>.</li>
<li>A <strong>FIFO queue</strong> first pops the node that was added to
the queue first. It is used in <strong>breadth-first
search</strong>.</li>
<li>A <strong>LIFO queue</strong> pops first the most recently added
node. It is used in <strong>depth-frist search</strong>.</li>
</ul>
<h2 id="measuring-problem-solving-performance">Measuring Problem-Solving
Performance</h2>
<p>An algorithm’s performance can be evaluated in four ways:</p>
<ul>
<li><strong>Completeness</strong>: Is the algorithm guaranteed to find a
solution when there is one, and to correctly report failure when there
is not?</li>
<li><strong>Cost optimality</strong>: Does it find a solution with the
lowest path cost of all solutions?</li>
<li><strong>Time complexity</strong>: How long does it take to find a
solution?</li>
<li><strong>Space complexity</strong>: How much memory is needed to
perform the search?</li>
</ul>
<p>For an implicit state space, complexity can be measured in terms of
<span class="math inline">\(d\)</span>, the <strong>depth</strong> or
number of actions in an optimal solution; <span
class="math inline">\(m\)</span>, the <strong>maximum number of actions
in any path</strong>; and <span class="math inline">\(b\)</span>, the
<strong>branching factor</strong> or number of successors of a node that
need to be considered.</p>
<h1 id="uninformed-search-strategies">Uninformed Search Strategies</h1>
<p>An uninformed search algorithm is given no clue about how close a
state is to the goBal(s).</p>
<h2 id="breadth-first-search">Breadth-First Search</h2>
<p>When all actions have the same cost, an appropriate strategy is
breadth-first-search, in which the root node is expanded first, then all
the successors of the root node are expanded next, then their
successors, and so on.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Breadth-First Search</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BreathFirstSearch</span>(<span class="params"><span class="attr">problem</span>: <span class="title class_">Problem</span></span>): <span class="title class_">Node</span> | <span class="title class_">Failure</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(problem.<span class="property">initial</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (problem.<span class="title function_">isGoal</span>(node.<span class="property">state</span>)) <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> frontier = <span class="title class_">FIFOQueue</span>&lt;<span class="title class_">Node</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> reached = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">    frontier.<span class="title function_">push</span>(node)</span><br><span class="line">    reached.<span class="title function_">add</span>(problem.<span class="property">initial</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!frontier.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = frontier.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">const</span> children = <span class="title class_">Expand</span>(problem, node)</span><br><span class="line">        children.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> s = child.<span class="property">state</span></span><br><span class="line">            <span class="keyword">if</span> (problem.<span class="title function_">isGoal</span>(s)) <span class="keyword">return</span> child</span><br><span class="line">            <span class="keyword">if</span> (!reached.<span class="title function_">has</span>(s)) &#123;</span><br><span class="line">                reached.<span class="title function_">add</span>(s)</span><br><span class="line">                frontier.<span class="title function_">push</span>(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uniform Cost Search</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UniformCostSearch</span>(<span class="params"><span class="attr">problem</span>: <span class="title class_">Problem</span></span>): <span class="title class_">Node</span> | <span class="title class_">Failture</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">BestFirstSearch</span>(problem, <span class="title class_">PathCost</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Suppose a uniform tree where every state has <span
class="math inline">\(b\)</span> successors, the total number of nodes
generated is</p>
<p><span class="math display">\[
1 + b + b^2 + \cdots + b^d = O(b^d)
\]</span></p>
<p>All the nodes remain in memory, so both time and space complexity are
<span class="math inline">\(O(b^d)\)</span>.</p>
<aside>
<p>💡 In general, exponential-complexity search problems cannot be
solved by uninformed search for any but the smallest instances.</p>
</aside>
<h2 id="dijkstras-algorithm-or-uniform-cost-search">Dijkstra’s Algorithm
or Uniform-Cost Search</h2>
<p>When actions have different costs, an obvious choice is to use
best-first search where <strong>the evaluation function is the cost of
the path from the root to the current node</strong>. This is called
Dijkstra’s algorithm or uniform-cost search by the AI community.</p>
<p>Given the cost of the optimal solution <span
class="math inline">\(C^*\)</span> and <span
class="math inline">\(\epsilon\)</span>, a lower bound on the cost of
each action, then the algorithm’s worst-case time and space complexity
is <span class="math inline">\(O(b^{1 + \lfloor C^* / \epsilon
\rfloor})\)</span>, which can be much bettwen than <span
class="math inline">\(b^d\)</span>. This is because uniform-cost search
can explore large trees of actions with low costs before exploring paths
involving a high-cost and perhaps useful action.</p>
<h2 id="depth-first-search-and-the-problem-of-memory">Depth-First Search
and the Problem of Memory</h2>
<p><strong>Depth-first search</strong> always expands the
<strong>deepest</strong> node in the frontier first. It could be
implemented as a call to BEST-FIRST-SEARCH where the evaluation function
<span class="math inline">\(f\)</span> is the negative of the depth.</p>
<p>In infinite state spaces, depth-first search is not systematic: it
can get stuck going down an infinite path, even if there are no
cycles.</p>
<p>But where a tree-like search is feasible, depth-first search has much
smaller needs for memory. A reached table is no kept at all, and the
frontier is very small. A memory complexity of a depth-first tree-like
search is <span class="math inline">\(O(bm)\)</span>, where <span
class="math inline">\(b\)</span> is the branching factor and <span
class="math inline">\(m\)</span> is the maximum depth of the tree.</p>
<aside>
<p>💡 Because of its parsimonious use of memory, depth-first tree-like
search has been adopted as the basic workhorse of many areas of AI.</p>
</aside>
<h2 id="depth-limited-and-iterative-deepening-search">Depth-Limited and
Iterative Deepening Search</h2>
<p>To keep depth-first search from wandering down and infinite path, we
can use depth-limited search, a version of depth-first search in which
we supply a depth limit, <span class="math inline">\(l\)</span>, and
treat all nodes in depth <span class="math inline">\(l\)</span> as if
they had no successors. The time complexity is <span
class="math inline">\(O(b^l)\)</span> and the space complexity is <span
class="math inline">\(O(bl)\)</span>.</p>
<p><strong>Iterative deepening search</strong> solves the problem of
picking a good value for <span class="math inline">\(l\)</span> by
trying all values: first 0, then 1, then 2 and so on —— until either a
solution is found, or the depth limited search returns the
<strong>failure value</strong> rather than the <strong>cutoff
value</strong>.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterative Deepening Search</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">IterativeDeepeningSearch</span>(<span class="params"><span class="attr">problem</span>: <span class="title class_">Problem</span></span>): <span class="title class_">Node</span> | <span class="title class_">Failure</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">DepthLimitedSearch</span>(problem, depth)</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="variable constant_">CUTOFF</span>) <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DepthLimitedSearch</span>(<span class="params"><span class="attr">problem</span>: <span class="title class_">Problem</span>, <span class="attr">limit</span>: <span class="built_in">number</span></span>): <span class="title class_">Node</span> | <span class="title class_">Failure</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> frontier = <span class="title class_">LIFOQueue</span>&lt;<span class="title class_">Node</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Failure</span></span><br><span class="line"></span><br><span class="line">    frontier.<span class="title function_">push</span>(problem.<span class="property">initial</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!frontier.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = frontier.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">if</span> (problem.<span class="title function_">isGoal</span>(node.<span class="property">state</span>)) <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Depth</span>.<span class="property">node</span> &gt; limit) &#123;</span><br><span class="line">            result = <span class="variable constant_">CUTOFF</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">IsCycle</span>(node)) &#123;</span><br><span class="line">            <span class="title class_">Expand</span>(problem, node).<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">                frontier.<span class="title function_">push</span>(child)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="/assets/images/2023-03-23-solving-problems-by-searching/4-iterations-of-ids.png"
alt="Four iterations of iterative deepening search for goal M on a binary tree, with the depth limit varying from 0 to 3. Note the interior nodes form a single path. The triangle marks the node to expand next; green nodes with dark outlines are on the frontier; the very faint nodes probably can’t be part of a solution with this depth limit." />
<figcaption aria-hidden="true">Four iterations of iterative deepening
search for goal M on a binary tree, with the depth limit varying from 0
to 3. Note the interior nodes form a single path. The triangle marks the
node to expand next; green nodes with dark outlines are on the frontier;
the very faint nodes probably can’t be part of a solution with this
depth limit.</figcaption>
</figure>
<aside>
<p>💡 In general, iterative deepening is the preferred uninformed search
method when the search state space is larger than can fit in memory and
the depth of the solution is not known.</p>
</aside>
<h2 id="bidirectional-search">Bidirectional Search</h2>
<p>Bidirectional search simultaneously searches forward from the initial
state and backwards from the goal state(s), hoping that the two searches
will meet. The motivation is that <span class="math inline">\(b^{d/2} +
b^{d/2}\)</span> is much less than <span
class="math inline">\(b^d\)</span>.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bidirectional Best-First Search</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">BIBF_Search</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">problemF</span>: <span class="title class_">Problem</span>,    <span class="comment">// forward problem</span></span></span><br><span class="line"><span class="params">    <span class="attr">fF</span>: <span class="title class_">EvaluateFunction</span>, <span class="comment">// evaluate function for forward problem</span></span></span><br><span class="line"><span class="params">    <span class="attr">problemB</span>: <span class="title class_">Problem</span>,    <span class="comment">// backward problem</span></span></span><br><span class="line"><span class="params">    <span class="attr">fB</span>: <span class="title class_">EvaluateFunction</span>, <span class="comment">// evaluate function for backward problem</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Node</span> | <span class="title class_">Failure</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nodeF = <span class="keyword">new</span> <span class="title class_">Node</span>(problemF.<span class="property">initial</span>)</span><br><span class="line">    <span class="keyword">const</span> nodeB = <span class="keyword">new</span> <span class="title class_">Node</span>(problemB.<span class="property">initial</span>)</span><br><span class="line">    <span class="keyword">const</span> frontierF = <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Node</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> frontierB = <span class="title class_">PriorityQueue</span>&lt;<span class="title class_">Node</span>&gt;()</span><br><span class="line">    <span class="keyword">const</span> reachedF = &#123; [nodeF.<span class="property">state</span>]: nodeF &#125;</span><br><span class="line">    <span class="keyword">const</span> reachedB = &#123; [nodeB.<span class="property">state</span>]: nodeB &#125;</span><br><span class="line"></span><br><span class="line">    frontierF.<span class="title function_">push</span>(nodeF)</span><br><span class="line">    frontierB.<span class="title function_">push</span>(nodeB)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> solution = <span class="title class_">Failure</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="title class_">Terminated</span>(solution, frontierF, frontierB)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">fF</span>(frontierF.<span class="title function_">top</span>()) &lt; <span class="title function_">fB</span>(frontierB.<span class="title function_">top</span>())) &#123;</span><br><span class="line">            solution = <span class="title class_">Proceed</span>(</span><br><span class="line">                <span class="variable constant_">FORWARD</span>, prblemF, frontierF, reachedF,</span><br><span class="line">                reachedB, solution)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            solution = <span class="title class_">Proceed</span>(</span><br><span class="line">                <span class="variable constant_">BACKWARD</span>, prblemB, frontierB, reachedB,</span><br><span class="line">                reachedF, solution)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solution</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Proceed</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">dir</span>: FORWARD | BACKWARD,</span></span><br><span class="line"><span class="params">    <span class="attr">problem</span>: <span class="title class_">Problem</span>,</span></span><br><span class="line"><span class="params">    frontier, reached, reached2, solution</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = frontier.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="title class_">Expand</span>(problem, node).<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> s = child.<span class="property">state</span></span><br><span class="line">        <span class="keyword">if</span> (!reached[s] || <span class="title class_">PathCost</span>(child) &lt; <span class="title class_">PathCost</span>(reached[s])) &#123;</span><br><span class="line">            reached[s] = child</span><br><span class="line">            frontier.<span class="title function_">push</span>(child)</span><br><span class="line">            <span class="keyword">if</span> (reached2[s]) &#123;</span><br><span class="line">                solution2 = <span class="title class_">JoinNodes</span>(dir, child, reached2[s])</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">PathCost</span>(solution2) &lt; <span class="title class_">PathCost</span>(solution)) &#123;</span><br><span class="line">                    solution = solution2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> solution</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For this to work, we need to keep track of two frontiers and two
tables of reached states, and we need to be able to reason backwards: if
state <span class="math inline">\(s&#39;\)</span> is a successor of
<span class="math inline">\(s\)</span> in the forward direction, then we
need to know that <span class="math inline">\(s\)</span> is a successor
of <span class="math inline">\(s&#39;\)</span> in the backward
direction.</p>
<h2 id="comparing-uninformed-search-algorithms">Comparing Uninformed
Search Algorithms</h2>
<figure>
<img
src="/assets/images/2023-03-23-solving-problems-by-searching/algo-comparison.png"
alt="Evaluation of search algorithms. b is the branching factor; m is the maximum depth of the search tree; d is the depth of the shallowest solution, or is m when there is no solution; l is the depth limit. Superscript caveats are as follows: 1 complete if b is finite, and the state space either has a solution or is finite. 2 complete if all action costs are ≥ ε &gt; 0; 3 cost-optimal if action costs are all identical; 4 if both directions are breadth-first or uniform-cost." />
<figcaption aria-hidden="true">Evaluation of search algorithms.
<em>b</em> is the branching factor; <em>m</em> is the maximum depth of
the search tree; <em>d</em> is the depth of the shallowest solution, or
is <em>m</em> when there is no solution; l is the depth limit.
Superscript caveats are as follows: 1 complete if <em>b</em> is finite,
and the state space either has a solution or is finite. 2 complete if
all action costs are ≥ ε &gt; 0; 3 cost-optimal if action costs are all
identical; 4 if both directions are breadth-first or
uniform-cost.</figcaption>
</figure>
<h1 id="informedheuristic-search-strategies">Informed(Heuristic) Search
Strategies</h1>
<p><strong>Informed Search</strong> strategy —— one that uses
domain-specific hints about the location of goals —— can find solutions
more efficiently than an uninformed strategy. This hints come in the
form of a <strong>heuristic function</strong>, denoted <span
class="math inline">\(h(n)\)</span>:</p>
<p><span class="math display">\[
h(n) = \small \text{estimated cost of the cheapest path from the state
at node } n \text{ to a goal state}
\]</span></p>
<h2 id="greedy-best-first-search">Greedy Best-First Search</h2>
<p><strong>Greedy best-first search</strong> is a form of best-first
search that expands first the node with the lowest <span
class="math inline">\(h(n)\)</span> value —— the node that appears to be
closest to the goal. So the evaluation function <span
class="math inline">\(f(n) = h(n)\)</span>.</p>
<h2 id="a-search">A* Search</h2>
<p>A* search uses the evaluation function</p>
<p><span class="math display">\[
f(n) = g(n) + h(n)
\]</span></p>
<p>where <span class="math inline">\(g(n)\)</span> is the path cost from
the initial state to node <span class="math inline">\(n\)</span>, and
<span class="math inline">\(h(n)\)</span> is the estimated cost of the
shortest path from <span class="math inline">\(n\)</span> to a goal
state, so we have</p>
<p><span class="math display">\[
f(n) = \small \text{estimated cost of the best path that continues from
} n \text{ to a goal.}
\]</span></p>
<p>An example of A* search is shown as below.</p>
<figure>
<img
src="/assets/images/2023-03-23-solving-problems-by-searching/a-star-example.png"
alt="Stages in an A* search for Bucharest. Notes are labeled with f = g + h. The h values are the straight-line distances to Bucharest." />
<figcaption aria-hidden="true">Stages in an A* search for Bucharest.
Notes are labeled with f = g + h. The h values are the straight-line
distances to Bucharest.</figcaption>
</figure>
<p>Stages in an A* search for Bucharest. Notes are labeled with f = g +
h. The h values are the straight-line distances to Bucharest.</p>
<p>Whether A* is cost-optimal depends on certain properties of the
heuristic. A key property is <strong>admissibility</strong>: an
admissible heuristic is one that never overestimates the cost to reach a
goal.</p>
<p>A slightly stronger property is called <strong>consistency</strong>.
A heuristic <span class="math inline">\(h(n)\)</span> is consistent if,
for every node <span class="math inline">\(n\)</span> and every
successor <span class="math inline">\(n&#39;\)</span> of <span
class="math inline">\(n\)</span> generated by an action <span
class="math inline">\(a\)</span>, we have</p>
<p><span class="math display">\[
h(n) \leq c(n, a, n&#39;) + h(n&#39;)
\]</span></p>
<p><img
src="/assets/images/2023-03-23-solving-problems-by-searching/triangular-inequality.png" /></p>
<p>This is a form of the <strong>triangle inequality</strong>. If the
heuristic <span class="math inline">\(h\)</span> is consistent, then the
single number <span class="math inline">\(h(n)\)</span> will be less
than the sum of the cost <span class="math inline">\(c(n, a,
a&#39;)\)</span> of the action from <span
class="math inline">\(n\)</span> to <span
class="math inline">\(n&#39;\)</span> plus the heuristic estimate <span
class="math inline">\(h(n&#39;)\)</span>.</p>
<aside>
<p>💡 Every consistent heuristic is admissible (but not vice versa), so
with a consistent heuristic, A* is cost-optimal. In addition, with a
consistent heuristic, the first time we reach a state it will be on an
optimal path, so we never have to re-add a state to the frontier, and
never have to change an entry in reached.</p>
</aside>
<h2 id="search-contours">Search Contours</h2>
<p>A useful way to visualize a search is to draw contours in the state
space. Inside the contour labeled <span
class="math inline">\(c\)</span>, all nodes have <span
class="math inline">\(f(n) = g(n) + h(n) \leq c\)</span>. With
uninform-cost search, the contours will be “circular” around the start
state, spreading out equally in all directions with no preference
towards the goal. With A* search using a good heuristic, the <span
class="math inline">\(g+h\)</span> bands will stretch toward a goal
state and become more narrowly focused around an optimal path.</p>
<p>If <span class="math inline">\(C^*\)</span> is the cost of the
optimal solution path, then we can say the following:</p>
<ul>
<li>A* expands all nodes that can be reached from the initial state on a
path where every node on the path has <span class="math inline">\(f(n)
&lt; C^*\)</span>. We say these are <strong>surely expanded
nodes</strong>.</li>
<li>A* might then expand some of the nodes right on the “goal contour”
(where <span class="math inline">\(f(n) = C^*\)</span>) before selecting
a goal node.</li>
<li>A* expands no nodes with <span class="math inline">\(f(n) &gt;
C^*\)</span>.</li>
</ul>
<p>We say that A* with a consistent heuristic is <strong>optimally
efficient</strong> in the sense that any algorithm that extends search
paths from the initial state, and uses the same heuristic information,
must expand all nodes that are surely expanded by A*.</p>
<aside>
<p>💡 That A* search is complete, cost-optimal, and optimally efficient
among all such algorithms is rather satisfying. Unfortunately, it does
not mean that A* is the answer to all our searching needs. <strong>The
catch is that for many problems, the number of nodes expanded can be
exponential in the length of the solution.</strong></p>
</aside>
<h2
id="satisficing-search-inadmissible-heuristic-and-weighted-a">Satisficing
Search: Inadmissible Heuristic and Weighted A*</h2>
<p>A* search has many good qualities, but it expands a lot of nodes. We
can explore fewer nodes (taking less time and space) if we are willing
to accept solutions that are suboptimal, but are “good enough” —— what
are called <strong>satisficing solutions</strong>. If we allow A* search
to use an <strong>inadmissible heuristic</strong> —— one that may
overestimate —— then we risk missing the optimal solution, but the
heuristic can potentially be more accurate, thereby reducing the number
of nodes expanded.</p>
<figure>
<img
src="/assets/images/2023-03-23-solving-problems-by-searching/grid-search.png"
alt="Two searches on the same grid: (a) an A∗ search and (b) a weighted A∗ search with weight W = 2. The gray bars are obstacles, the purple line is the path from the green start to red goal, and the small dots are states that were reached by each search. On this particular problem, weighted A∗ explores 7 times fewer states and finds a path that is 5% more costly." />
<figcaption aria-hidden="true">Two searches on the same grid: (a) an A∗
search and (b) a weighted A∗ search with weight <em>W</em> = 2. The gray
bars are obstacles, the purple line is the path from the green start to
red goal, and the small dots are states that were reached by each
search. On this particular problem, weighted A∗ explores 7 times fewer
states and finds a path that is 5% more costly.</figcaption>
</figure>
<p>Two searches on the same grid: (a) an A∗ search and (b) a weighted A∗
search with weight <em>W</em> = 2. The gray bars are obstacles, the
purple line is the path from the green start to red goal, and the small
dots are states that were reached by each search. On this particular
problem, weighted A∗ explores 7 times fewer states and finds a path that
is 5% more costly.</p>
<p>With an approach called <strong>weighted A* search</strong> where we
weight the heuristic value more heavily, giving us the evaluation
function <span class="math inline">\(f(n) = g(n) + W \times
h(n)\)</span>, for some <span class="math inline">\(W &gt;
1\)</span>.</p>
<p>In general, if the optimal solution costs <span
class="math inline">\(C^*\)</span>, a weighted A* search will find a
solution that costs somewhere between <span
class="math inline">\(C^*\)</span> and <span class="math inline">\(W
\times C^*\)</span>; but in practice we usually get results much closer
to <span class="math inline">\(C^*\)</span> than <span
class="math inline">\(W \times C^*\)</span>.</p>
<p>Searches can be considered that evaluates states by combining <span
class="math inline">\(g\)</span> and <span
class="math inline">\(h\)</span> in various ways.</p>
<p><span class="math display">\[
\begin{aligned}
\text{A* search}: &amp;\ \ \ \ \  g(n) + h(n) &amp; (W = 1) \\
\text{Uniform-cost search}: &amp;\ \ \ \ \  g(n) &amp; (W = 0) \\
\text{Greedy best-first search}: &amp;\ \ \ \ \  h(n) &amp; (W = \infty)
\\
\text{Weighted A* search}: &amp;\ \ \ \ \  g(n) + W \times h(n) &amp; (1
&lt; W &lt; \infty) \\
\end{aligned}
\]</span></p>
<p>There are a variety of suboptimal search algorithms, which can be
characterized by the criteria for what counts as “good enough”.</p>
<ul>
<li><strong>bounded suboptimal search</strong>: we look for a solution
that is guaranteed to be within a constant factor <span
class="math inline">\(W\)</span> of the optimal cost.</li>
<li><strong>bounded-cost search</strong>: we look for a solution whose
cost is less than some constant <span
class="math inline">\(C\)</span>.</li>
<li><strong>unbounded-cost search</strong>: we accept a solution of any
cost, as long as we can find it quickly.</li>
</ul>
<h2 id="memory-bounded-search">Memory-Bounded Search</h2>
<p>Memory is split between the <strong>frontier</strong> and the
<strong>reached</strong> states.</p>
<p><strong>Beam search</strong> limits the size of the frontier. The
easiest approach is to keep only the <span
class="math inline">\(k\)</span> nodes with the best <span
class="math inline">\(f\)</span>-scores, discarding any other expanded
nodes.</p>
<p>**Iterative-deepening A* search (IDA*)** is to A* what
iterative-deepening search is to depth-first: IDA* gives us the benefits
of A* without the requirement to keep all reached states in memory, at a
cost of visiting some states multiple times. In IDA* the cutoff is the
<span class="math inline">\(f\)</span>-cost <span
class="math inline">\((g + h)\)</span>; at each iteration, the cutoff
value is the smallest <span class="math inline">\(f\)</span>-cost of any
node that exceeded the cutoff on the previous iteration.</p>
<p><strong>Recursive best-first search (RBFS)</strong> attempts to mimic
the operation of standard best-first search, but using only linear
space.</p>
<h2 id="bidirectional-heuristic-search">Bidirectional Heuristic
Search</h2>
<p>Bidirectional search is sometimes more efficient than unidirectional
search, sometimes not. In general, if we have a very good heuristic,
then A* search produces search contours that are focused on the goal,
and adding bidirectional search does not help much.</p>
<h1 id="heuristic-functions">Heuristic Functions</h1>
<h2 id="the-effect-of-heuristic-accuracy-on-performance">The Effect of
Heuristic Accuracy on Performance</h2>
<p>One way to characterize the quality of a heuristic is the
<strong>effective branching factor <span
class="math inline">\(b^*\)</span></strong>. If the total number of
nodes generated by A* for a particular problem is <span
class="math inline">\(N\)</span> and the solution depth is <span
class="math inline">\(d\)</span>, then <span
class="math inline">\(b^*\)</span> is the branching factor that a
uniform tree of depth <span class="math inline">\(d\)</span> would have
to have in order to contain <span class="math inline">\(N+1\)</span>
nodes. Thus</p>
<p><span class="math display">\[
N + 1 = 1 + b^* + (b^*)^2 + \cdots + (b^*)^d
\]</span></p>
<aside>
<p>💡 The effective branching factor can vary across problem instances,
but usually for a specific domain it is fairly constant across all
nontrivial problem instances. <strong>Therefore, experimental
measurements of <span class="math inline">\(b^*\)</span> on a small set
of problems can provide a good guide to the heuristic’s overall
usefulness.</strong></p>
</aside>
<h2 id="generating-heuristic-from-relaxed-problems">Generating Heuristic
from Relaxed Problems</h2>
<p>A problem with fewer restrictions on the actions is called a
<strong>relaxed problem</strong>. The state-space graph of the relaxed
problem is a supergraph of the original state space because the removal
of restrictions creates added edges in the graph. Because the relaxed
problem adds edges to the state-space graph, any optimal solution in
this original problem is, by definition, also a solution in the relaxed
problem; but the relaxed problem may have better solutions if the added
edges provide shortcuts. Hence, <strong>the cost of an optimal solution
to a relaxed problem is an admissible heuristic for the original
problem.</strong></p>
<p>For example, if the 8-puzzle actions are described as</p>
<blockquote>
<p>A tile can move from square X to square Y if X is adjacent to Y and Y
is blank.</p>
</blockquote>
<p>we can generate three relaxed problems by removing one or both of the
conditions:</p>
<ol type="a">
<li><p>A tile can move from square X to square Y if X is adjacent to
Y.</p></li>
<li><p>A tile can move from square X to square Y if Y is blank.</p></li>
<li><p>A tile can move from square X to square Y.</p></li>
</ol>
<p>From (a), we can derive Manhattan distance as a heuristic function.
From (c), we can derive direct distance as a heuristic function.</p>
<p>If a collection of admissible heuristic <span
class="math inline">\(h_1, h_2, \dots, h_m\)</span> is available for a
problem and none of them is clearly better than others, which should be
choose? As it turns out, we can have the best of all worlds, by
defining</p>
<p><span class="math display">\[
h(n) = \max\{h_1(n), h_2(n), \dots, h_k(n)\}
\]</span></p>
<p>This composite heuristic picks whichever function is most accurate on
the node in question. Because the <span
class="math inline">\(h_i\)</span> components are admissible, <span
class="math inline">\(h\)</span> is admissible (and if <span
class="math inline">\(h_i\)</span> are all consistent, <span
class="math inline">\(h\)</span> is consistent). Furthermore, <span
class="math inline">\(h\)</span> dominates all of its component
heuristics.</p>
<h2
id="generating-heuristics-from-subproblems-pattern-databases">Generating
Heuristics from Subproblems: Pattern Databases</h2>
<p>Admissible heuristics can also be derived from the solution cost of a
subproblem of a given problem.</p>
<h2 id="generating-heuristics-with-landmarks">Generating Heuristics with
Landmarks</h2>
<p>A perfect heuristic could be generated by precomputing and storing
the cost of the optimal path between <strong>landmark points</strong>
from the vertices. For each landmark <span
class="math inline">\(L\)</span> and for each other vertex <span
class="math inline">\(v\)</span> in the graph, we compute and store
<span class="math inline">\(C^*(v, L)\)</span>, the exact cost of the
optimal path from <span class="math inline">\(v\)</span> to <span
class="math inline">\(L\)</span>. Given the stored <span
class="math inline">\(C^*\)</span> tables, we can easily create an
efficient heuristic: the minimum, over all landmarks, of the cost of
getting from the current node to the landmark, and then to the goal:</p>
<p><span class="math display">\[
h_L(n) = \min_{L \in \text{Landmarks}} C^*(n, L) + C^*(L, goal)
\]</span></p>
<p><span class="math inline">\(h_L(n)\)</span> is efficient but not
admissible.</p>
<p><span class="math display">\[
h_{DH}(n) = \max_{L \in \text{Landmarks}} \big|C^*(n, L) - C^*(goal,
L)\big|
\]</span></p>
<p>This is called a <strong>differential heuristic</strong>.</p>
<h1 id="summary">Summary</h1>
<ul>
<li>Before an agent can start searching, a well-defined
<strong>problem</strong> must be formulated.</li>
<li>A problem consists of five parts: the <strong>initial
state</strong>, a set of <strong>actions</strong>, a <strong>transition
model</strong> describing the results of those actions, a set of
<strong>goal states</strong>, and an <strong>action cost
function</strong>.</li>
<li>The environment of the problem is represented by a <strong>state
space graph</strong>. A <strong>path</strong> through the state space (a
sequence of actions) from the initial state to a goal state is a
<strong>solution</strong>.</li>
<li>Search algorithms generally treat states and actions as
<strong>atomic</strong>, without any internal structure (although we
introduced features of states when it came time to do learning).</li>
<li>Search algorithms are judged on the basis of
<strong>completeness</strong>, <strong>cost optimality</strong>,
<strong>time complexity</strong>, and <strong>space
complexity</strong>.</li>
<li><strong>Uninformed search</strong> methods have access only to the
problem definition. Algorithms build a search tree in an attempt to find
a solution. Algorithms differ based on which node they expand first:
<ul>
<li><strong>Best-first search</strong> selects nodes for expansion using
an <strong>evaluation function</strong>.</li>
<li><strong>Breadth-first search</strong> expands the shallowest nodes
first; it is complete, optimal for unit action costs, but has
exponential space complexity.</li>
<li><strong>Uniform-cost search</strong> expands the node with lowest
path cost, <span class="math inline">\(g(n)\)</span>, and is optimal for
general action costs.</li>
<li><strong>Depth-first search</strong> expands the deepest unexpanded
node first. It is neither complete nor optimal, but has linear space
complexity. <strong>Depth-limited search</strong> adds a depth
bound.</li>
<li><strong>Iterative deepening search</strong> calls depth-first search
with increasing depth limits until a goal is found. It is complete when
full cycle checking is done, optimal for unit action costs, has time
complexity comparable to breadth-first search, and has linear space
complexity.</li>
<li><strong>Bidirectional search</strong> expands two frontiers, one
around the initial state and one around the goal, stopping when the two
frontiers meet.</li>
</ul></li>
<li><strong>Informed search</strong> methods have access to a
<strong>heuristic function</strong> <span
class="math inline">\(h(n)\)</span> that estimates the cost of a
solution from <span class="math inline">\(n\)</span>. They may have
access to additional information such as pattern databases with solution
costs.
<ul>
<li><strong>Greedy best-first search</strong> expands nodes with minimal
<span class="math inline">\(h(n)\)</span>. It is not optimal but is
often efficient.</li>
<li><strong>A</strong>∗ <strong>search</strong> expands nodes with
minimal <span class="math inline">\(f (n) = g(n) + h(n)\)</span>. A∗ is
complete and optimal, provided that <span
class="math inline">\(h(n)\)</span> is admissible. The space complexity
of A∗ is still an issue for many problems.</li>
<li><strong>Bidirectional A</strong>∗ <strong>search</strong> is
sometimes more efficient than A∗ itself.</li>
<li><strong>IDA</strong>∗ (iterative deepening A∗ search) is an
iterative deepening version of A∗, and thus adresses the space
complexity issue.</li>
<li><strong>RBFS</strong> (recursive best-first search) and
<strong>SMA</strong>∗ (simplified memory-bounded A∗) are robust, optimal
search algorithms that use limited amounts of memory; given enough time,
they can solve problems for which A∗ runs out of memory.</li>
<li><strong>Beam search</strong> puts a limit on the size of the
frontier; that makes it incomplete and suboptimal, but it often finds
reasonably good solutions and runs faster than complete searches.</li>
<li><strong>Weighted A</strong>∗ search focuses the search towards a
goal, expanding fewer nodes, but sacrificing optimality.</li>
</ul></li>
<li>The performance of heuristic search algorithms depends on the
quality of the heuristic function. One can sometimes construct good
heuristics by relaxing the problem definition, by storing precomputed
solution costs for subproblems in a pattern database, by defining
landmarks, or by learning from experience with the problem class.</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

<script>
  function resizeIframe() {
    const obj = document.querySelector('.post-body iframe');
    obj.onload = () => {
      obj.style.height = obj.contentWindow.document.documentElement.scrollHeight + 'px';
      obj.setAttribute('scrolling', 'no');
    }
  }
  resizeIframe();
</script>
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>bifnudo
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/" title="Solving Problems by Searching">https://aquietzero.github.io/2023/03/23/reading/ai-a-modern-approach/2023-03-23-solving-problems-by-searching/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag"># 方法论</a>
              <a href="/tags/AI/" rel="tag"># AI</a>
              <a href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag"># 搜索</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/03/08/reading/ai-a-modern-approach/2023-03-08-intelligent-agents/" rel="prev" title="Intelligent Agents">
                  <i class="fa fa-angle-left"></i> Intelligent Agents
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/25/reading/ai-a-modern-approach/2023-03-25-search-in-complex-environments/" rel="next" title="Search in Complex Environments">
                  Search in Complex Environments <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">bifnudo</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">305k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:28</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/aquietzero" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"version":"11.5.0","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.5.0/mermaid.min.js","integrity":"sha256-K7oJiQlDulzl24ZUFOywuYme1JqBBvQzK6m8qHjt9Gk="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"aquietzero-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
