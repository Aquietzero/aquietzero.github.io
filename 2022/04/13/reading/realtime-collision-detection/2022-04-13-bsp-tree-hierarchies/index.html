<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CAgbalumo:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"aquietzero.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"width":null},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Of the many spatial partitioning methods available, the BSP tree is the most versatile. It can perform the same tasks as the k-d tree, the quadtree, or the octree, but not vice versa. BSP Trees A bina">
<meta property="og:type" content="article">
<meta property="og:title" content="BSP Tree Hierarchies">
<meta property="og:url" content="https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/index.html">
<meta property="og:site_name" content="NullSpace">
<meta property="og:description" content="Of the many spatial partitioning methods available, the BSP tree is the most versatile. It can perform the same tasks as the k-d tree, the quadtree, or the octree, but not vice versa. BSP Trees A bina">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aquietzero.github.io/assets/images/2022-04-13-bsp-tree-hierarchies/bsp-trees.png">
<meta property="article:published_time" content="2022-04-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-19T07:11:29.530Z">
<meta property="article:author" content="bifnudo">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="游戏引擎">
<meta property="article:tag" content="碰撞检测">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aquietzero.github.io/assets/images/2022-04-13-bsp-tree-hierarchies/bsp-trees.png">


<link rel="canonical" href="https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/","path":"2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/","title":"BSP Tree Hierarchies"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>BSP Tree Hierarchies | NullSpace</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BCZ3TL69CD"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-BCZ3TL69CD","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">NullSpace</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section">标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section">关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#bsp-trees"><span class="nav-number">1.</span> <span class="nav-text">BSP Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#types-of-bsp-trees"><span class="nav-number">2.</span> <span class="nav-text">Types of BSP Trees</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#node-storing-bsp-trees"><span class="nav-number">2.1.</span> <span class="nav-text">Node-storing BSP Trees</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leaf-storing-bsp-trees"><span class="nav-number">2.2.</span> <span class="nav-text">Leaf-storing BSP Trees</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#solid-leaf-bsp-trees"><span class="nav-number">2.3.</span> <span class="nav-text">Solid-leaf BSP Trees</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#building-the-bsp-tree"><span class="nav-number">3.</span> <span class="nav-text">Building the BSP Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#selecting-dividing-planes"><span class="nav-number">3.1.</span> <span class="nav-text">Selecting Dividing Planes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#evaluating-dividing-planes"><span class="nav-number">3.2.</span> <span class="nav-text">Evaluating Dividing Planes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#classifying-polygons-with-respect-to-a-plane"><span class="nav-number">3.3.</span> <span class="nav-text">Classifying
Polygons with Respect to a Plane</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#splitting-polygons-against-a-plane"><span class="nav-number">3.4.</span> <span class="nav-text">Splitting Polygons Against a
Plane</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#splitting-robustness"><span class="nav-number">3.5.</span> <span class="nav-text">Splitting Robustness</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#using-the-bsp-tree"><span class="nav-number">4.</span> <span class="nav-text">Using the BSP Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#testing-a-point-against-a-solid-leaf-bsp-tree"><span class="nav-number">4.1.</span> <span class="nav-text">Testing a Point
Against a Solid-leaf BSP Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intersecting-a-ray-against-a-solid-leaf-bsp-tree"><span class="nav-number">4.2.</span> <span class="nav-text">Intersecting a
Ray Against a Solid-leaf BSP Tree</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bifnudo"
      src="/assets/images/me.webp">
  <p class="site-author-name" itemprop="name">bifnudo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/aquietzero" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aquietzero" rel="noopener me" target="_blank">GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/aquietzero" title="豆瓣 → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;aquietzero" rel="noopener me" target="_blank">豆瓣</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoyunhaosss@gmail.com" title="E-Mail → mailto:zhaoyunhaosss@gmail.com" rel="noopener me" target="_blank">E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/images/me.webp">
      <meta itemprop="name" content="bifnudo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NullSpace">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="BSP Tree Hierarchies | NullSpace">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BSP Tree Hierarchies
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-13T00:00:00+08:00">2022-04-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Of the many spatial partitioning methods available, the BSP tree is
the most versatile. <strong>It can perform the same tasks as the k-d
tree, the quadtree, or the octree, but not vice versa.</strong></p>
<h1 id="bsp-trees">BSP Trees</h1>
<p>A binary space-partitioning tree (or BSP tree) is a binary tree
structure that recursively partitions space into pairs of subspaces
<strong>with respect to dividing planes of arbitrary position and
orientation.</strong> If the space being partitioned is n-dimensional,
the dividing planes are (n-1)-dimensional hyperplanes.</p>
<figure>
<img src="/assets/images/2022-04-13-bsp-tree-hierarchies/bsp-trees.png"
alt="The successive division of a square into four convex subspaces and the cor- responding BSP tree. (a) The initial split. (b) The first second-level split. (c) The second second-level split." />
<figcaption aria-hidden="true">The successive division of a square into
four convex subspaces and the cor- responding BSP tree. (a) The initial
split. (b) The first second-level split. (c) The second second-level
split.</figcaption>
</figure>
<p>The successive division of a square into four convex subspaces and
the cor- responding BSP tree. (a) The initial split. (b) The first
second-level split. (c) The second second-level split.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/recursive-division.png"
alt="The recursive division of space in half can be used as (a) a spatial partitioning over a number of objects. It can also be used as (b) a volume or boundary representation of an object." />
<figcaption aria-hidden="true">The recursive division of space in half
can be used as (a) a spatial partitioning over a number of objects. It
can also be used as (b) a volume or boundary representation of an
object.</figcaption>
</figure>
<p>The recursive division of space in half can be used as (a) a spatial
partitioning over a number of objects. It can also be used as (b) a
volume or boundary representation of an object.</p>
<p>Usage of BSP Trees:</p>
<ul>
<li>Solve the hidden-surface problem. The BSP built in preprocessing
phase can be traversed at runtime to give the correct (back-to-front or
front-to-back) sorting order of objects or individual polygons from an
arbitrary viewpoint.</li>
<li>Ray tracing.</li>
<li>Constructive solid geometry (CSG).</li>
<li>Robot motion.</li>
<li>Path planning.</li>
<li>Spatial partitioning.</li>
<li>Volume representation.</li>
</ul>
<aside>
<p>💡 Constructing a BSP tree from stratch or recomputing parts of a
tree is sufficiently expensive that they are rarely built or modified at
runtime. For this reason, <strong>BSP trees are primarily used to hold
static background geometry. Collision detection among moving objects is
usually handled throught some other method.</strong></p>
</aside>
<h1 id="types-of-bsp-trees">Types of BSP Trees</h1>
<h2 id="node-storing-bsp-trees">Node-storing BSP Trees</h2>
<p>A node-storing (or node-based) BSP tree is autopartitioning, thus
selecting supporting planes of faces from the geometry as the dividing
planes used during construction.</p>
<aside>
<p>💡 With the advent of 3D graphics hardware, using node-storing trees
no longer makes sense in that they excessively divide the geometry into
individual polygons.</p>
</aside>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/polygon-geometry.png"
alt="(a) The original 12-polygon input geometry. (b)The initial dividing plane is selected to pass through face A (and face G). (c) For the next ply of the tree dividing planes are selected to pass through faces B and H." />
<figcaption aria-hidden="true">(a) The original 12-polygon input
geometry. (b)The initial dividing plane is selected to pass through face
<em>A</em> (and face <em>G</em>). (c) For the next ply of the tree
dividing planes are selected to pass through faces <em>B</em> and
<em>H</em>.</figcaption>
</figure>
<ol type="a">
<li>The original 12-polygon input geometry. (b)The initial dividing
plane is selected to pass through face <em>A</em> (and face <em>G</em>).
(c) For the next ply of the tree dividing planes are selected to pass
through faces <em>B</em> and <em>H</em>.</li>
</ol>
<h2 id="leaf-storing-bsp-trees">Leaf-storing BSP Trees</h2>
<p>Leaf-storing BSP tree refers to any BSP tree in which geometry is
stored in the leaves of the tree rather than in the internal nodes.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/leaf-storing-bsp-trees.png"
alt="First steps of the construction of a leaf-storing BSP tree, using the same geometry as before." />
<figcaption aria-hidden="true">First steps of the construction of a
leaf-storing BSP tree, using the same geometry as before.</figcaption>
</figure>
<p>First steps of the construction of a leaf-storing BSP tree, using the
same geometry as before.</p>
<h2 id="solid-leaf-bsp-trees">Solid-leaf BSP Trees</h2>
<p>Solid-leaf BSP trees are built to represent the solid volume occupied
by the input geometry. That is, dividing planes are ultimately selected
to separate the solid volume from the exterior of the object.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/dividing-planes.png"
alt="A solid figure cut by a number of dividing planes and the resulting solid-leaf BSP tree." />
<figcaption aria-hidden="true">A solid figure cut by a number of
dividing planes and the resulting solid-leaf BSP tree.</figcaption>
</figure>
<p>A solid figure cut by a number of dividing planes and the resulting
solid-leaf BSP tree.</p>
<h1 id="building-the-bsp-tree">Building the BSP Tree</h1>
<p>Building a BSP tree involves three steps.</p>
<ol type="1">
<li>Selection of a partitioning plane.</li>
<li>Partitioning of the input geometry into two sets with respect to the
plane; the geometry in front of the plane and the geometry behind it.
Geometry that straddles the plane is split to the plane before
partitioning.</li>
<li>The forming of a tree by connecting with a new tree node the two
subtrees created by recursively calling the construction algorithm with
the two partitioned sets obtained in the previous step.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constructs BSP tree from an input vector of polygons. Pass ‘depth’ as 0 on entry</span></span><br><span class="line"><span class="function">BSPNode *<span class="title">BuildBSPTree</span><span class="params">(std::vector&lt;Polygon *&gt; &amp;polygons, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return NULL tree if there are no polygons</span></span><br><span class="line">    <span class="keyword">if</span> (polygons.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get number of polygons in the input vector</span></span><br><span class="line">    <span class="type">int</span> numPolygons = polygons.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If criterion for a leaf is matched, create a leaf node from remaining polygons</span></span><br><span class="line">    <span class="keyword">if</span> (depth &gt;= MAX_DEPTH || numPolygons &lt;= MIN_LEAF_SIZE) || ...etc...)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BSPNode</span>(polygons);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select best possible partitioning plane based on the input geometry</span></span><br><span class="line">    Plane splitPlane = **PickSplittingPlane**(polygons);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Polygon *&gt; frontList, backList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test each polygon against the dividing plane, adding them</span></span><br><span class="line">    <span class="comment">// to the front list, back list, or both, as appropriate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numPolygons; i++) &#123;</span><br><span class="line">        Polygon *poly = polygons[i], *frontPart, *backPart;</span><br><span class="line">        <span class="keyword">switch</span> (**ClassifyPolygonToPlane**(poly, splitPlane)) &#123;</span><br><span class="line">            <span class="keyword">case</span> COPLANAR_WITH_PLANE:</span><br><span class="line">                <span class="comment">// What’s done in this case depends on what type of tree is being</span></span><br><span class="line">                <span class="comment">// built. For a node-storing tree, the polygon is stored inside</span></span><br><span class="line">                <span class="comment">// the node at this level (along with all other polygons coplanar</span></span><br><span class="line">                <span class="comment">// with the plane). Here, for a leaf-storing tree, coplanar polygons</span></span><br><span class="line">                <span class="comment">// are sent to either side of the plane. In this case, to the front</span></span><br><span class="line">                <span class="comment">// side, by falling through to the next case</span></span><br><span class="line">            <span class="keyword">case</span> IN_FRONT_OF_PLANE:</span><br><span class="line">                frontList.<span class="built_in">push_back</span>(poly);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BEHIND_PLANE:</span><br><span class="line">                backList.<span class="built_in">push_back</span>(poly);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STRADDLING_PLANE:</span><br><span class="line">                <span class="comment">// Split polygon to plane and send a part to each side of the plane</span></span><br><span class="line">                **SplitPolygon**(*poly, splitPlane, &amp;frontPart, &amp;backPart);</span><br><span class="line">                frontList.<span class="built_in">push_back</span>(frontPart);</span><br><span class="line">                backList.<span class="built_in">push_back</span>(backPart);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Recursively build child subtrees and return new tree root combining them</span></span><br><span class="line">    BSPNode *frontTree = <span class="built_in">BuildBSPTree</span>(frontList, depth + <span class="number">1</span>);</span><br><span class="line">    BSPNode *backTree = <span class="built_in">BuildBSPTree</span>(backList, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BSPNode</span>(frontTree, backTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For a node-storing tree and a solid-leaf tree, the recursive
construction proceeds until the set of remaining input polygons becomes
empty. The construction of a leaf-storing BSP tree is typically stopped
when:</p>
<ul>
<li>The leaf contains less than some preset number of polygons.</li>
<li>A fixed cutoff depth has been reached.</li>
<li>A good dividing plane cannot be found.</li>
</ul>
<h2 id="selecting-dividing-planes">Selecting Dividing Planes</h2>
<p>Autopartitioning by restricting the dividing planes as the supporting
planes of the geometry may not be an optimal solution.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/selecting-dividing-planes.png"
alt="(a) A configuration of 12 faces wherein all possible auto-partitioned dividing planes end up splitting four faces. (b) Using arbitrary splits can allow the configuration to be partitioned in such a way that the problem disappears or is reduced." />
<figcaption aria-hidden="true">(a) A configuration of 12 faces wherein
all possible auto-partitioned dividing planes end up splitting four
faces. (b) Using arbitrary splits can allow the configuration to be
partitioned in such a way that the problem disappears or is
reduced.</figcaption>
</figure>
<p>Another problem of using just auto-partitioning is that for convex
shapes, the resulting tree will in some sense be maximally unbalanced,
with a depth equal to the number of faces in the sphere.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/auto-partitioned-bsp-tree.png"
alt="(a)An auto partitioned BSP tree for a polygonal sphere has worst-case O(n) height. (b) Allowing arbitrary cuts across the sphere, tree height is reduced to O(log n). (c) Naylor’s hybrid approach of alternating auto-partitioning and general cuts also allows a boundary representation of the sphere to have O(log n) height, additionally providing early outs." />
<figcaption aria-hidden="true">(a)An auto partitioned BSP tree for a
polygonal sphere has worst-case <em>O</em>(<em>n</em>) height. (b)
Allowing arbitrary cuts across the sphere, tree height is reduced to
<em>O</em>(log <em>n</em>). (c) Naylor’s hybrid approach of alternating
auto-partitioning and general cuts also allows a boundary representation
of the sphere to have <em>O</em>(log <em>n</em>) height, additionally
providing early outs.</figcaption>
</figure>
<h2 id="evaluating-dividing-planes">Evaluating Dividing Planes</h2>
<p>Two strategies particularly relevant to collision detection are to
pick planes so as to minimize splitting of geometry and to attempt to
balance the geometry equally on both sides of the splitting plane.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/part-of-a-city-grid.png"
alt="Part of a city grid split to minimize straddling polygons (A), balance the number of polygons on either side of the dividing plane (B), and compromise between minimizing straddling and balancing of polygons (C )." />
<figcaption aria-hidden="true">Part of a city grid split to minimize
straddling polygons (<em>A</em>), balance the number of polygons on
either side of the dividing plane (<em>B</em>), and compromise between
minimizing straddling and balancing of polygons (<em>C</em>
).</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Given a vector of polygons, attempts to compute a good splitting plane</span></span><br><span class="line"><span class="function">Plane <span class="title">PickSplittingPlane</span><span class="params">(std::vector&lt;Polygon *&gt; &amp;polygons)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Blend factor for optimizing for balance or splits (should be tweaked)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> K = <span class="number">0.8f</span>;</span><br><span class="line">    <span class="comment">// Variables for tracking best splitting plane seen so far</span></span><br><span class="line">    Plane bestPlane;</span><br><span class="line">    <span class="type">float</span> bestScore = FLT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the plane of each polygon as a dividing plane</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; polygons.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> numInFront = <span class="number">0</span>, numBehind = <span class="number">0</span>, numStraddling = <span class="number">0</span>;</span><br><span class="line">        Plane plane = <span class="built_in">GetPlaneFromPolygon</span>(polygons[i]);</span><br><span class="line">        <span class="comment">// Test against all other polygons</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; polygons.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// Ignore testing against self</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Keep standing count of the various poly-plane relationships</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">ClassifyPolygonToPlane</span>(polygons[j], plane)) &#123;</span><br><span class="line">                <span class="keyword">case</span> POLYGON_COPLANAR_WITH_PLANE:</span><br><span class="line">                    <span class="comment">/* Coplanar polygons treated as being in front of plane */</span></span><br><span class="line">                <span class="keyword">case</span> POLYGON_IN_FRONT_OF_PLANE:</span><br><span class="line">                    numInFront++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> POLYGON_BEHIND_PLANE:</span><br><span class="line">                    numBehind++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> POLYGON_STRADDLING_PLANE:</span><br><span class="line">                        numStraddling++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Compute score as a weighted combination (based on K, with K in range</span></span><br><span class="line">        <span class="comment">// 0..1) between balance and splits (lower score is better)</span></span><br><span class="line">        <span class="type">float</span> score = K * numStraddling + (<span class="number">1.0f</span> - K) * <span class="built_in">Abs</span>(numInFront - numBehind);</span><br><span class="line">        <span class="keyword">if</span> (score &lt; bestScore) &#123;</span><br><span class="line">            bestScore = score;</span><br><span class="line">            bestPlane = plane;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestPlane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<aside>
<p>💡 The variable <strong>K</strong> controlling the blending of the
least-crossed and balancing strategies is given as a constant.
<strong>In practice, it can be made to vary with the depth of the
current node during construction.</strong></p>
</aside>
<h2 id="classifying-polygons-with-respect-to-a-plane">Classifying
Polygons with Respect to a Plane</h2>
<p>After a dividing plane has been selected all polygons must be
partitioned with respect to this plane into one of the following four
categories.</p>
<ul>
<li>Polygons that lie in front of the dividing plane.</li>
<li>Polygons that lie behind the dividing plane.</li>
<li>Polygons straddling the dividing plane.</li>
<li>Polygons coincident with the dividing plane.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Classify point p to a plane thickened by a given thickness epsilon</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClassifyPointToPlane</span><span class="params">(Point p, Plane plane)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compute signed distance of point from plane</span></span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">Dot</span>(plane.n, p) - plane.d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Classify p based on the signed distance</span></span><br><span class="line">    <span class="keyword">if</span> (dist &gt; PLANE_THICKNESS_EPSILON)</span><br><span class="line">        <span class="keyword">return</span> POINT_IN_FRONT_OF_PLANE;</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; -PLANE_THICKNESS_EPSILON)</span><br><span class="line">        <span class="keyword">return</span> POINT_BEHIND_PLANE;</span><br><span class="line">    <span class="keyword">return</span> POINT_ON_PLANE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Considering with the floating point accuracy, <strong>thick
planes</strong> are used. Rules of classifying different categories.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/thick-planes.png"
alt="Triangle ABC lies behind the plane and triangle DEF lies in front of the plane. Triangle GHI straddles the plane and triangle JKL lies on the plane." />
<figcaption aria-hidden="true">Triangle <em>ABC</em> lies behind the
plane and triangle <em>DEF</em> lies in front of the plane. Triangle
<em>GHI</em> straddles the plane and triangle <em>JKL</em> lies on the
plane.</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return value specifying whether the polygon ‘poly’ lies in front of, // behind of, on, or straddles the plane ‘plane’</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ClassifyPolygonToPlane</span><span class="params">(Polygon *poly, Plane plane)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Loop over all polygon vertices and count how many vertices</span></span><br><span class="line">    <span class="comment">// lie in front of and how many lie behind of the thickened plane int numInFront = 0, numBehind = 0;</span></span><br><span class="line">    <span class="type">int</span> numVerts = poly-&gt;<span class="built_in">NumVertices</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVerts; i++) &#123;</span><br><span class="line">        Point p = poly-&gt;<span class="built_in">GetVertex</span>(i);</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">ClassifyPointToPlane</span>(p, plane)) &#123;</span><br><span class="line">            <span class="keyword">case</span> POINT_IN_FRONT_OF_PLANE:</span><br><span class="line">                numInFront++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> POINT_BEHIND_PLANE:</span><br><span class="line">                numBehind++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If vertices on both sides of the plane, the polygon is straddling</span></span><br><span class="line">    <span class="keyword">if</span> (numBehind != <span class="number">0</span> &amp;&amp; numInFront != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> POLYGON_STRADDLING_PLANE;</span><br><span class="line">    <span class="comment">// If one or more vertices in front of the plane and no vertices behind // the plane, the polygon lies in front of the plane</span></span><br><span class="line">    <span class="keyword">if</span> (numInFront != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> POLYGON_IN_FRONT_OF_PLANE;</span><br><span class="line">    <span class="comment">// Ditto, the polygon lies behind the plane if no vertices in front of // the plane, and one or more vertices behind the plane</span></span><br><span class="line">    <span class="keyword">if</span> (numBehind != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> POLYGON_BEHIND_PLANE;</span><br><span class="line">    <span class="comment">// All vertices lie on the plane so the polygon is coplanar with the plane</span></span><br><span class="line">    <span class="keyword">return</span> POLYGON_COPLANAR_WITH_PLANE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="splitting-polygons-against-a-plane">Splitting Polygons Against a
Plane</h2>
<p>During BSP tree construction, when a polygon is found straddling a
dividing plane it must be split in two.</p>
<p>The act of clipping the polygon against a plane is commonly performed
using the <strong>Sutherland-Hodgman clipping algorithm</strong>.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/splitting-polygons-against-a-plane.png"
alt="Clipping the polygon ABDE illustrates the four cases of the Sutherland-Hodgman polygon-clipping algorithm. The points of the output polygon BCFA are shown in gray in the cases in which they are output." />
<figcaption aria-hidden="true">Clipping the polygon <em>ABDE</em>
illustrates the four cases of the Sutherland-Hodgman polygon-clipping
algorithm. The points of the output polygon <em>BCFA</em> are shown in
gray in the cases in which they are output.</figcaption>
</figure>
<p>Clipping the polygon <em>ABDE</em> illustrates the four cases of the
Sutherland-Hodgman polygon-clipping algorithm. The points of the output
polygon <em>BCFA</em> are shown in gray in the cases in which they are
output.</p>
<p>The algorithm proceeds one polygon edge at a time and has four cases
based on what sides of the clipping plane the edge startpoints and
endpoints lie.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/output-rules-for-the-clipping-algo.png"
alt="Output rules for the modified Sutherland–Hodgman clipping algorithm dealing with a thickened plane and retaining both parts of the polygon. The rules are given in terms of the directed segment AB. I represents the intersection point of AB with the clipping plane." />
<figcaption aria-hidden="true">Output rules for the modified
Sutherland–Hodgman clipping algorithm dealing with a thickened plane and
retaining both parts of the polygon. The rules are given in terms of the
directed segment <em>AB</em>. <em>I</em> represents the intersection
point of <em>AB</em> with the clipping plane.</figcaption>
</figure>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/protential-problem-of-clipping-algo.png"
alt="A potential problem with the modified clipping algorithm is that the resulting pieces (shown in dark gray) may overlap." />
<figcaption aria-hidden="true">A potential problem with the modified
clipping algorithm is that the resulting pieces (shown in dark gray) may
overlap.</figcaption>
</figure>
<p>For robust clipping of the polygon, so that no overlap exists between
the generated pieces, a full set of all nine possible cases is
necessary.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/final-modified-clipping-algo.png"
alt="The final modified clipping algorithm for robustly clipping a polygon against a thick plane." />
<figcaption aria-hidden="true">The final modified clipping algorithm for
robustly clipping a polygon against a thick plane.</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SplitPolygon</span><span class="params">(Polygon &amp;poly, Plane plane, Polygon **frontPoly, Polygon **backPoly)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numFront = <span class="number">0</span>, numBack = <span class="number">0</span>;</span><br><span class="line">    Point frontVerts[MAX_POINTS], backVerts[MAX_POINTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test all edges (a, b) starting with edge from last to first vertex</span></span><br><span class="line">    <span class="type">int</span> numVerts = poly.<span class="built_in">NumVertices</span>();</span><br><span class="line">    Point a = poly.<span class="built_in">GetVertex</span>(numVerts – <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> aSide = <span class="built_in">ClassifyPointToPlane</span>(a, plane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over all edges given by vertex pair (n - 1, n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; numVerts; n++) &#123;</span><br><span class="line">        Point b = poly.<span class="built_in">GetVertex</span>(n);</span><br><span class="line">        <span class="type">int</span> bSide = <span class="built_in">ClassifyPointToPlane</span>(b, plane);</span><br><span class="line">        <span class="keyword">if</span> (bSide == POINT_IN_FRONT_OF_PLANE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aSide == POINT_BEHIND_PLANE) &#123;</span><br><span class="line">                <span class="comment">// Edge (a, b) straddles, output intersection point to both sides</span></span><br><span class="line">                Point i = <span class="built_in">IntersectEdgeAgainstPlane</span>(a, b, plane);</span><br><span class="line">                <span class="built_in">assert</span>(<span class="built_in">ClassifyPointToPlane</span>(i, plane) == POINT_ON_PLANE);</span><br><span class="line">                frontVerts[numFront++] = backVerts[numBack++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In all three cases, output b to the front side</span></span><br><span class="line">            frontVerts[numFront++] = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bSide == POINT_BEHIND_PLANE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aSide == POINT_IN_FRONT_OF_PLANE) &#123;</span><br><span class="line">                <span class="comment">// Edge (a, b) straddles plane, output intersection point</span></span><br><span class="line">                Point i = <span class="built_in">IntersectEdgeAgainstPlane</span>(a, b, plane);</span><br><span class="line">                <span class="built_in">assert</span>(<span class="built_in">ClassifyPointToPlane</span>(i, plane) == POINT_ON_PLANE);</span><br><span class="line">                frontVerts[numFront++] = backVerts[numBack++] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aSide == POINT_ON_PLANE) &#123;</span><br><span class="line">                <span class="comment">// Output a when edge (a, b) goes from ‘on’ to ‘behind’ plane</span></span><br><span class="line">                backVerts[numBack++] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In all three cases, output b to the back side</span></span><br><span class="line">            backVerts[numBack++] = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b is on the plane. In all three cases output b to the front side</span></span><br><span class="line">            frontVerts[numFront++] = b;</span><br><span class="line">            <span class="comment">// In one case, also output b to back side</span></span><br><span class="line">            <span class="keyword">if</span> (aSide == POINT_BEHIND_PLANE)</span><br><span class="line">                backVerts[numBack++] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Keep b as the starting point of the next edge</span></span><br><span class="line">        a = b;</span><br><span class="line">        aSide = bSide;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create (and return) two new polygons from the two vertex lists</span></span><br><span class="line">    *frontPoly = <span class="keyword">new</span> <span class="built_in">Polygon</span>(numFront, frontVerts);</span><br><span class="line">    *backPoly = <span class="keyword">new</span> <span class="built_in">Polygon</span>(numBack, backVerts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="splitting-robustness">Splitting Robustness</h2>
<p>Consider the situation below. Two triangles <span
class="math inline">\(ABC\)</span> and <span
class="math inline">\(CBD\)</span> are given with their points in
counterclockwise. When splitting, due to the differences between
floating point arithmetic and real arithmetic, intersecting <span
class="math inline">\(BC\)</span> against a plane <span
class="math inline">\(P\)</span> does not, in general, result in the
same intersection point as intersecting <span
class="math inline">\(CB\)</span> with the same plane.</p>
<figure>
<img
src="/assets/images/2022-04-13-bsp-tree-hierarchies/splitting-robustness.png"
alt="(a) Original geometry of two triangles intersecting a plane. (b) Inconsistent handling of the shared edge results in two different intersection points, which introduces cracking. (c) The correct result when the shared edge is handled consistently." />
<figcaption aria-hidden="true">(a) Original geometry of two triangles
intersecting a plane. (b) Inconsistent handling of the shared edge
results in two different intersection points, <strong>which introduces
cracking</strong>. (c) The correct result when the shared edge is
handled consistently.</figcaption>
</figure>
<p>To robustly deal with this case, the clipping code must always
intersect the given edge consistently as either <span
class="math inline">\(BC\)</span> or <span
class="math inline">\(CB\)</span>, but not both.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (bSide == POINT_IN_FRONT_OF_PLANE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSide == POINT_BEHIND_PLANE) &#123;</span><br><span class="line">    <span class="comment">// Edge (a, b) straddles, output intersection point to both sides.</span></span><br><span class="line">    <span class="comment">// Consistently clip edge as ordered going from in front -&gt; behind</span></span><br><span class="line">    Point i = <span class="built_in">IntersectEdgeAgainstPlane</span>(b, a, plane);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="using-the-bsp-tree">Using the BSP Tree</h1>
<h2 id="testing-a-point-against-a-solid-leaf-bsp-tree">Testing a Point
Against a Solid-leaf BSP Tree</h2>
<p>Testing if a point lies in empty or solid space of a solid-leaf BSP
tree is a largely straightforward application. At each node, the point
is evaluated with respect to the dividing plane at that node. If the
point lies in front of the plane, the child node representing the front
tree is visited, and vice versa. Traversal continues until a leaf node
is reached, at which point the solidity of the leaf indicates the
result.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PointInSolidSpace</span><span class="params">(BSPNode *node, Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;<span class="built_in">IsLeaf</span>()) &#123;</span><br><span class="line">        <span class="comment">// Compute distance of point to dividing plane</span></span><br><span class="line">        <span class="type">float</span> dist = <span class="built_in">Dot</span>(node-&gt;plane.n, p) - node-&gt;plane.d;</span><br><span class="line">        <span class="keyword">if</span> (dist &gt; EPSILON) &#123;</span><br><span class="line">            <span class="comment">// Point in front of plane, so traverse front of tree</span></span><br><span class="line">            node = node-&gt;child[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dist &lt; -EPSILON) &#123;</span><br><span class="line">            <span class="comment">// Point behind of plane, so traverse back of tree</span></span><br><span class="line">            node = node-&gt;child[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Point on dividing plane; must traverse both sides</span></span><br><span class="line">            <span class="type">int</span> front = <span class="built_in">PointInSolidSpace</span>(node-&gt;child[<span class="number">0</span>], p);</span><br><span class="line">            <span class="type">int</span> back = <span class="built_in">PointInSolidSpace</span>(node-&gt;child[<span class="number">1</span>], p);</span><br><span class="line">            <span class="comment">// If results agree, return that, else point is on boundary</span></span><br><span class="line">            <span class="keyword">return</span> (front == back) ? front : POINT_ON_BOUNDARY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now at a leaf, inside/outside status determined by solid flag</span></span><br><span class="line">    <span class="keyword">return</span> node-&gt;<span class="built_in">IsSolid</span>() ? POINT_INSIDE : POINT_OUTSIDE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="intersecting-a-ray-against-a-solid-leaf-bsp-tree">Intersecting a
Ray Against a Solid-leaf BSP Tree</h2>
<p>The routine to intersect the ray <span class="math inline">\(R(t) = P
+ t\textbf{d}, t \in [t_{\min}, t_{\max}]\)</span> against a solid-leaf
BSP tree as follows. The time <span
class="math inline">\(t_{hit}\)</span> of the first intersection with a
solid leaf is returned when such an intersection exists.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Intersect ray/segment R(t) = p + t*d, tmin &lt;= t &lt;= tmax, against bsp tree</span></span><br><span class="line"><span class="comment">// ’node’, returning time thit of first intersection with a solid leaf, if any</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RayIntersect</span><span class="params">(BSPNode *node, Point p, Vector d, <span class="type">float</span> tmin, <span class="type">float</span> tmax, <span class="type">float</span> *thit)</span> </span>&#123;</span><br><span class="line">    std::stack&lt;BSPNode *&gt; nodeStack;</span><br><span class="line">    std::stack&lt;<span class="type">float</span>&gt; timeStack;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(node != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;<span class="built_in">IsLeaf</span>()) &#123;</span><br><span class="line">            <span class="type">float</span> denom = <span class="built_in">Dot</span>(node-&gt;plane.n, d);</span><br><span class="line">            <span class="type">float</span> dist = node-&gt;plane.d - <span class="built_in">Dot</span>(node-&gt;plane.n, p);</span><br><span class="line">            <span class="type">int</span> nearIndex = dist &gt; <span class="number">0.0f</span>;</span><br><span class="line">            <span class="comment">// If denom is zero, ray runs parallel to plane. In this case,</span></span><br><span class="line">            <span class="comment">// just fall through to visit the near side (the one p lies on)</span></span><br><span class="line">            <span class="keyword">if</span> (denom != <span class="number">0.0f</span>) &#123;</span><br><span class="line">                <span class="type">float</span> t = dist / denom;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0.0f</span> &lt;= t &amp;&amp; t &lt;= tmax) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t &gt;= tmin) &#123;</span><br><span class="line">                        <span class="comment">// Straddling, push far side onto stack,then visit near side</span></span><br><span class="line">                        nodeStack.<span class="built_in">push</span>(node-&gt;child[<span class="number">1</span> ∧ nearIndex]);</span><br><span class="line">                        timeStack.<span class="built_in">push</span>(tmax);</span><br><span class="line">                        tmax = t;</span><br><span class="line">                    &#125; <span class="keyword">else</span> nearIndex = <span class="number">1</span> ∧ nearIndex; <span class="comment">// 0 &lt;= t &lt; tmin, visit far side</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">            node = node-&gt;child[nearIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Now at a leaf. If it is solid, there’s a hit at time tmin, so exit</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;<span class="built_in">IsSolid</span>()) &#123;</span><br><span class="line">                *thit = tmin;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Exit if no more subtrees to visit, else pop off a node and continue</span></span><br><span class="line">            <span class="keyword">if</span> (nodeStack.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            tmin = tmax;</span><br><span class="line">            node = nodeStack.<span class="built_in">top</span>(); nodeStack.<span class="built_in">pop</span>();</span><br><span class="line">            tmax = timeStack.<span class="built_in">top</span>(); timeStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// No hit</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

<script>
  function resizeIframe() {
    const obj = document.querySelector('.post-body iframe');
    obj.onload = () => {
      obj.style.height = obj.contentWindow.document.documentElement.scrollHeight + 'px';
      obj.setAttribute('scrolling', 'no');
    }
  }
  resizeIframe();
</script>
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>bifnudo
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/" title="BSP Tree Hierarchies">https://aquietzero.github.io/2022/04/13/reading/realtime-collision-detection/2022-04-13-bsp-tree-hierarchies/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
              <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag"># 游戏引擎</a>
              <a href="/tags/%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/" rel="tag"># 碰撞检测</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/13/reading/realtime-collision-detection/2022-04-13-convexity-based-methods/" rel="prev" title="Convexity-based Methods">
                  <i class="fa fa-angle-left"></i> Convexity-based Methods
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/14/reading/realtime-collision-detection/2022-04-14-geometrical-robustness/" rel="next" title="Geometrical Robustness">
                  Geometrical Robustness <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">bifnudo</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">305k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:28</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/aquietzero" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"version":"11.5.0","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.5.0/mermaid.min.js","integrity":"sha256-K7oJiQlDulzl24ZUFOywuYme1JqBBvQzK6m8qHjt9Gk="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"aquietzero-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
